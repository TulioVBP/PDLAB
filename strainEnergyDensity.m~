function W = strainEnergyDensity(x,x_imp,u,theta_i,family,partialAreas,surfaceCorrection,ii,idb,par_omega,c,model,damage,history)
    W = 0;
    familySet = family(family~=0);
    dofi = [idb(2*ii-1) idb(2*ii)];
    m = weightedVolume(par_omega);
    horizon = par_omega(1);
    % Evaluate dilatation
    %if model.dilatation
    %    theta_i = dilatation(x,u,family,partialAreas,ii,idb,m,par_omega,c,model);
    %end
    neigh_ind = 1;
    for jj = familySet
            x_j = x_imp(jj,:);
            xi =  x_j - x(ii,:);
            dofj = [idb(2*jj-1) idb(2*jj)];
            eta = u(dofj)' - u(dofi)';
            norma = norm(xi);
            s = (norm(xi+eta) - norma)/norma;
            switch model.name
                case "PMB"
                    if exist('history','var')
                        mu = damageFactor(history(neigh_ind),x(ii,:),x_j,damage,[],model); % NoFail not required
                    else
                        mu = 1;
                    end
                    p = antiderivative(s,damage);
                    w = 1/2*c(1)*influenceFunction(norma,par_omega)*norma^2*p*mu;
                    W = W + w*partialAreas(neigh_ind)*surfaceCorrection(neigh_ind);
                case "Linearized LPS bond-based"
                    extension = dot(eta,xi)/norma;
                    w = 1/2*c(1)*influenceFunction(norma,par_omega)*extension^2/2;
                    W = W + w*partialAreas(neigh_ind)*surfaceCorrection(neigh_ind);
                case "Linearized LPS"
                    kappa = c(1)*m/2+c(2)*m/3;
                    alfa = c(2);
                    w = alfa/2*influenceFunction(norma,par_omega)*norma^2*(dot(eta,xi)/norma^2 - theta_i/3)^2;
                    W = W + w*partialAreas(neigh_ind)*surfaceCorrection(neigh_ind);
                    if (length(familySet)>1 && jj == familySet(end)) || b_end == true
                        W = W + kappa*theta_i^2/2;
                    end
                case "Lipton Free Damage"
                    if exist('history','var')
                        H = damageFactor(history(1,neigh_ind,:),x(ii,:),x(jj,:),damage,[],model);
                    else
                        H = [1 1 1];
                    end
                    Slin = dot(xi,eta)/norma^2;
                    V_delta = pi*horizon^2;
                    W = W+1/V_delta*(influenceFunction(norma,par_omega)*norma/horizon * H(1)*f_potential(Slin*sqrt(norma),c,damage))*partialAreas(neigh_ind)*surfaceCorrection(neigh_ind);
                    if (length(familySet)>1 && jj == familySet(end)) || b_end == true
                        %W = W/2; % Teste
                        W = W + 1/horizon^2*H(2)*g_potential(theta_i,c,damage);
                    end
                case "LPS 2D"
                    elong = norm(xi+eta) - norm(xi);
                    W =  W + c(2)/2*influenceFunction(norma,par_omega)*(elong-theta_i*norma/3)^2*partialAreas(neigh_ind)*surfaceCorrection(neigh_ind);
                    if (length(familySet)>1 && jj == familySet(end)) || b_end == true
                        W = W + c(1)*theta_i^2/2;
                    end
                otherwise
                    break
            end
            neigh_ind = neigh_ind + 1;
    end
end

function p = antiderivative(x,damage)
    % Modified PMB model
    %global S0 S1
    if damage.damageOn
        % Damage dependent crack
        alfa = 0.2; beta = 0.2; gamma = 1.4;
        if damage.phi > alfa
            Sc = damage.Sc*min(gamma,1+beta*(damage.phi-alfa)/(1-damage.phi));
        else
            Sc = damage.Sc;
        end
        S0 = [-0.98 0.95*Sc]; % S0- and S0+
        S1 = [-0.99 1.05*Sc]; % S1- and S1+
        % Evaluate integration constants
        A = [1 0 0 0 0; 0 1 0 0 0; 1 0 0 -1 0; 0 0 1 0 0; 0 0 -1 0 1];
        b = [S0(1)^2/2 - S0(1)/(S0(1) - S1(1))*(S0(1)^2/2 - S1(1)*S0(1));
            0;
            S0(1)/(S0(1) - S1(1))*(S1(1)^2/2);
            S0(2)^2/2 - S0(2)/(S1(2) - S0(2))*(-S0(2)^2/2 + S1(2)*S0(2));
            S0(2)/(S1(2) - S0(2))*S1(2)^2/2];
        C = A\b;
        if x <  S1(1)
            p = C(4); % C4
        elseif x < S0(1)
            p = S0(1)/(S0(1) - S1(1))*(x^2/2 - S1(1)*x) + C(1);
        elseif x < S0(2)
            p = x^2/2 + C(2);
        elseif x < S1(2)
            p = S0(2)/(S1(2) - S0(2))*(S1(2)*x - x^2/2) + C(3);
        else
            p = C(5);
        end
    else
        p = x^2/2;
    end
end

function theta = dilatation(x,u,family,partialAreas,ii,idb,m,par_omega,c,model)
    horizon = par_omega(1);
    familySet = family(family~=0);
    neigh_ind = 1;
    theta = 0;
    dofi = [idb(2*ii-1) idb(2*ii)];
    for jj = familySet
        dofj = [idb(2*jj-1) idb(2*jj)];
        xi = x(jj,:)-x(ii,:);
        norma = norm(xi);
        eta = u(dofj)'-u(dofi)';
        switch model.name            
            case "Linearized LPS"
                theta= theta + 3/m*influenceFunction(norma,par_omega)*dot(eta,xi)*partialAreas(neigh_ind);
            case "Lipton Free Damage"
                V_delta = pi*horizon^2;
                S_linear = dot(xi,eta)/norma^2;
                theta = theta + 1/V_delta*influenceFunction(norma,par_omega)*norma^2*S_linear*partialAreas(neigh_ind);                
            case "LPS 2D"
                nu = c(3);
                elong = norm(xi+eta) - norm(xi);
                theta = theta + 2*(2*nu-1)/(nu-1)/m*influenceFunction(norma,par_omega)*norma*elong*partialAreas(neigh_ind);
            otherwise
                break;
        end
        neigh_ind = neigh_ind+1;
    end
end

function ff = f_potential(x,c,damage)
r1 = 3.0;
r2 = 3.0;
if damage.damageOn
    if x <= r1
        ff = c(1)*x^2/2;
    elseif x > r2
        ff = x;
    end
else
    ff = c(1)*x^2/2;
end
end

function gg = g_potential(x,c,damage)
r1 = 3.0;
r2 = 3.0;
if damage.damageOn
    if x <= r1
        gg = c(2)*x^2/2;
    elseif x > r2
        gg = x;
    end
else
    gg = c(2)*x^2/2;
end

end
