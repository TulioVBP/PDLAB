% Explicit time - dynamic solver

function [u_n,phi,W] = solver_DynamicExplicit(x,maxNeigh,t,idb,b,bc_set,familyMat,partialAreas,T,crackIn,noFailZone)
    global rho
    ndof = 2*length(x) - length(bc_set);
    dt = abs(t(2) - t(1));
    dt_crit = criticalTimeStep(x,familyMat,partialAreas);
    dt_ratio = dt/dt_crit;
    % Verify if dt is small enough
    if dt_ratio < 1
        disp("Given time-step " + num2str(dt) +" sec is less than the critical time-step, " + num2str(dt_crit) + ...
            " sec, and the safety factor is " + num2str(dt_ratio) + ". The simulation should converge.")
    else 
       disp("Given time-step " + num2str(dt) + " sec is greater than the critical time-step, " + num2str(dt_crit) + ...
            " sec, and the safety factor is " + num2str(dt_ratio)+ ". The simulation shall explode.")
    end
    % INITIALIZE SIMULATION MATRICES 
        % M = rho * eye(length(x)); % Inertia matrix
        % Minv = 1/rho * eye(length(x)); % Inverse of the inertial matrix
        Minv = 1/rho; % Diagonal and with the same value: scalar
        S_max = zeros(length(x),maxNeigh);
        phi = zeros(length(x),length(t)); % No initial damage
        W = zeros(length(x),length(t)); % No initial deformation
        % Initial condition
        u_n = zeros(2*length(x),length(t)); % 2*N x n  2D matrix
        v_n = zeros(2*length(x),3); % Velocity Verlet matrix [i i+1/2]: by initializing it to zero, the rigid motion is eliminated.ffz
        bn = b;%bodyForce(x,stresses,m,h,A);
        for n = 1:length(t)-1
            % TIME LOOP
            fn = zeros(2*length(x),1);
            for ii = 1:length(x)
                dofi = [idb(2*ii-1) idb(2*ii)];
                % Loop on the nodes
                family = familyMat(ii,familyMat(ii,:)~=0);
               for jj = family
                   dofj = [idb(2*jj-1) idb(2*jj)];
                   % Loop on their neighbourhood
                   noFail = noFailZone(ii) || noFailZone(jj); % True if node ii or jj is in the no fail zone
                   neig_index = find(familyMat(ii,:) == jj);
                   [fij,S_max(ii,neig_index)] = T(x(ii,:),x(jj,:),u_n(dofi,n)',u_n(dofj,n)',S_max(ii,neig_index),crackIn,noFail);
                   Vj = partialAreas(ii,neig_index);
                   fn(dofi) = fn(dofi) + (fij')*Vj;
                   % Damage index
                    phi(ii,n) = phi(ii,n) + damageIndex(x,u_n(:,n),familyMat(ii,neig_index),partialAreas(ii,neig_index),ii,crackIn,idb,noFailZone); % Damage index
                    W(ii,n) = W(ii,n) + strainEnergyDensity(x,u_n(:,n),familyMat(ii,neig_index),partialAreas(ii,neig_index),ii,S_max(ii,neig_index),idb);
               end
               %phi(ii,n) = damageIndex(x,u_n(:,(2*n-1):(2*n)),family(ii,:),partialAreas(ii,:),ii,crackIn); % Damage index
            end
            % ############ VELOCITY VERLET ALGORITHM ###############
            % Solving for the dof
            % Step 1 - Midway velocity
            v_n(1:ndof,2) = v_n(1:ndof,1) + dt/2*Minv*(fn(1:ndof) + bn(1:ndof)); % V(n+1/2)
            %u_n(:,(2*(n+1)-1):2*(n+1)) = u_n(:,(2*n-1):2*n) + dt*v_n(:,3:4); % u(n+1)
            u_n(1:ndof,n+1) = u_n(1:ndof,n) + dt*v_n(1:ndof,2); % u(n+1)
            v_n(1:ndof,1) = v_n(1:ndof,2) + dt/2*Minv*(fn(1:ndof) + bn(1:ndof)); % V(n+1) is stored in the next V(n)
            % Solving for the constraint nodes
            u_const = zeros(length(v_n)-(ndof),1);
            u_const(bc_set(:,3) == 0) = bc_set(bc_set(:,3) == 0,2); % Defining the displacements for the nodes with no velocity
            u_const = u_const + bc_set(:,3)*dt;
            u_n()
            % ############ COUNTING THE PROCESSING TIME #############
            disp("Time = " + num2str(t(n)) + " secs. Percentage of the process: " + num2str(n/(length(t)-1)*100) + "%")
            %pause
        end
end

function dt_crit = criticalTimeStep(x,family,partialAreas)
    global rho c1 omega horizon
    dt = zeros(length(x),1);
    for ii = 1:length(x)
        familyOfI = family(ii,family(ii,:)~=0);
        den = 0;
        for jj = familyOfI
            neigh_index = family(ii,:) == jj;
            xi = x(jj,:) - x(ii,:);
            norma = norm(xi);
            C = c1*influenceFunction(norma,horizon,omega)*norma/norma^3*...
            [xi(1)^2 xi(1)*xi(2); xi(1)*xi(2) xi(2)^2]; % PMB model only
            den = den + norm(C)*partialAreas(neigh_index);
        end
        dt(ii) = sqrt(2*rho/den);
    end
    dt_crit = min(dt); % Critical time step
end

